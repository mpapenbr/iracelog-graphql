// Code generated by BobGen psql v0.38.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"hash/maphash"

	"github.com/lib/pq"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/orm"
)

var TableNames = struct {
	CCars       string
	CCarDrivers string
	CCarEntries string
	CCarTeams   string
	Events      string
	Tenants     string
	Tracks      string
}{
	CCars:       "c_car",
	CCarDrivers: "c_car_driver",
	CCarEntries: "c_car_entry",
	CCarTeams:   "c_car_team",
	Events:      "event",
	Tenants:     "tenant",
	Tracks:      "track",
}

var ColumnNames = struct {
	CCars       cCarColumnNames
	CCarDrivers cCarDriverColumnNames
	CCarEntries cCarEntryColumnNames
	CCarTeams   cCarTeamColumnNames
	Events      eventColumnNames
	Tenants     tenantColumnNames
	Tracks      trackColumnNames
}{
	CCars: cCarColumnNames{
		ID:            "id",
		EventID:       "event_id",
		Name:          "name",
		NameShort:     "name_short",
		CarID:         "car_id",
		CCarClassID:   "c_car_class_id",
		FuelPCT:       "fuel_pct",
		PowerAdjust:   "power_adjust",
		WeightPenalty: "weight_penalty",
		DryTireSets:   "dry_tire_sets",
	},
	CCarDrivers: cCarDriverColumnNames{
		ID:          "id",
		CCarEntryID: "c_car_entry_id",
		DriverID:    "driver_id",
		Name:        "name",
		Initials:    "initials",
		AbbrevName:  "abbrev_name",
		Irating:     "irating",
		LicLevel:    "lic_level",
		LicSubLevel: "lic_sub_level",
		LicString:   "lic_string",
	},
	CCarEntries: cCarEntryColumnNames{
		ID:           "id",
		EventID:      "event_id",
		CCarID:       "c_car_id",
		CarIdx:       "car_idx",
		CarNumber:    "car_number",
		CarNumberRaw: "car_number_raw",
	},
	CCarTeams: cCarTeamColumnNames{
		ID:          "id",
		CCarEntryID: "c_car_entry_id",
		TeamID:      "team_id",
		Name:        "name",
	},
	Events: eventColumnNames{
		ID:                   "id",
		EventKey:             "event_key",
		Name:                 "name",
		Description:          "description",
		EventTime:            "event_time",
		RaceloggerVersion:    "racelogger_version",
		TeamRacing:           "team_racing",
		MultiClass:           "multi_class",
		NumCarTypes:          "num_car_types",
		NumCarClasses:        "num_car_classes",
		IrSessionID:          "ir_session_id",
		TrackID:              "track_id",
		PitSpeed:             "pit_speed",
		ReplayMinTimestamp:   "replay_min_timestamp",
		ReplayMinSessionTime: "replay_min_session_time",
		ReplayMaxSessionTime: "replay_max_session_time",
		Sessions:             "sessions",
		IrSubSessionID:       "ir_sub_session_id",
		TenantID:             "tenant_id",
	},
	Tenants: tenantColumnNames{
		ID:         "id",
		ExternalID: "external_id",
		Name:       "name",
		APIKey:     "api_key",
		Active:     "active",
	},
	Tracks: trackColumnNames{
		ID:            "id",
		Name:          "name",
		ShortName:     "short_name",
		Config:        "config",
		TrackLength:   "track_length",
		Sectors:       "sectors",
		PitSpeed:      "pit_speed",
		PitEntry:      "pit_entry",
		PitExit:       "pit_exit",
		PitLaneLength: "pit_lane_length",
	},
}

var (
	SelectWhere     = Where[*dialect.SelectQuery]()
	UpdateWhere     = Where[*dialect.UpdateQuery]()
	DeleteWhere     = Where[*dialect.DeleteQuery]()
	OnConflictWhere = Where[*clause.ConflictClause]() // Used in ON CONFLICT DO UPDATE
)

func Where[Q psql.Filterable]() struct {
	CCars       cCarWhere[Q]
	CCarDrivers cCarDriverWhere[Q]
	CCarEntries cCarEntryWhere[Q]
	CCarTeams   cCarTeamWhere[Q]
	Events      eventWhere[Q]
	Tenants     tenantWhere[Q]
	Tracks      trackWhere[Q]
} {
	return struct {
		CCars       cCarWhere[Q]
		CCarDrivers cCarDriverWhere[Q]
		CCarEntries cCarEntryWhere[Q]
		CCarTeams   cCarTeamWhere[Q]
		Events      eventWhere[Q]
		Tenants     tenantWhere[Q]
		Tracks      trackWhere[Q]
	}{
		CCars:       buildCCarWhere[Q](CCarColumns),
		CCarDrivers: buildCCarDriverWhere[Q](CCarDriverColumns),
		CCarEntries: buildCCarEntryWhere[Q](CCarEntryColumns),
		CCarTeams:   buildCCarTeamWhere[Q](CCarTeamColumns),
		Events:      buildEventWhere[Q](EventColumns),
		Tenants:     buildTenantWhere[Q](TenantColumns),
		Tracks:      buildTrackWhere[Q](TrackColumns),
	}
}

var Preload = getPreloaders()

type preloaders struct {
	CCar       cCarPreloader
	CCarDriver cCarDriverPreloader
	CCarEntry  cCarEntryPreloader
	CCarTeam   cCarTeamPreloader
	Event      eventPreloader
	Tenant     tenantPreloader
	Track      trackPreloader
}

func getPreloaders() preloaders {
	return preloaders{
		CCar:       buildCCarPreloader(),
		CCarDriver: buildCCarDriverPreloader(),
		CCarEntry:  buildCCarEntryPreloader(),
		CCarTeam:   buildCCarTeamPreloader(),
		Event:      buildEventPreloader(),
		Tenant:     buildTenantPreloader(),
		Track:      buildTrackPreloader(),
	}
}

var (
	SelectThenLoad = getThenLoaders[*dialect.SelectQuery]()
	InsertThenLoad = getThenLoaders[*dialect.InsertQuery]()
	UpdateThenLoad = getThenLoaders[*dialect.UpdateQuery]()
)

type thenLoaders[Q orm.Loadable] struct {
	CCar       cCarThenLoader[Q]
	CCarDriver cCarDriverThenLoader[Q]
	CCarEntry  cCarEntryThenLoader[Q]
	CCarTeam   cCarTeamThenLoader[Q]
	Event      eventThenLoader[Q]
	Tenant     tenantThenLoader[Q]
	Track      trackThenLoader[Q]
}

func getThenLoaders[Q orm.Loadable]() thenLoaders[Q] {
	return thenLoaders[Q]{
		CCar:       buildCCarThenLoader[Q](),
		CCarDriver: buildCCarDriverThenLoader[Q](),
		CCarEntry:  buildCCarEntryThenLoader[Q](),
		CCarTeam:   buildCCarTeamThenLoader[Q](),
		Event:      buildEventThenLoader[Q](),
		Tenant:     buildTenantThenLoader[Q](),
		Track:      buildTrackThenLoader[Q](),
	}
}

func thenLoadBuilder[Q orm.Loadable, T any](name string, f func(context.Context, bob.Executor, T, ...bob.Mod[*dialect.SelectQuery]) error) func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
	return func(queryMods ...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
		return orm.Loader[Q](func(ctx context.Context, exec bob.Executor, retrieved any) error {
			loader, isLoader := retrieved.(T)
			if !isLoader {
				return fmt.Errorf("object %T cannot load %q", retrieved, name)
			}

			err := f(ctx, exec, loader, queryMods...)

			// Don't cause an issue due to missing relationships
			if errors.Is(err, sql.ErrNoRows) {
				return nil
			}

			return err
		})
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]()
	UpdateJoins = getJoins[*dialect.UpdateQuery]()
	DeleteJoins = getJoins[*dialect.DeleteQuery]()
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	CCars       joinSet[cCarJoins[Q]]
	CCarDrivers joinSet[cCarDriverJoins[Q]]
	CCarEntries joinSet[cCarEntryJoins[Q]]
	CCarTeams   joinSet[cCarTeamJoins[Q]]
	Events      joinSet[eventJoins[Q]]
	Tenants     joinSet[tenantJoins[Q]]
	Tracks      joinSet[trackJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		CCars:       buildJoinSet[cCarJoins[Q]](CCarColumns, buildCCarJoins),
		CCarDrivers: buildJoinSet[cCarDriverJoins[Q]](CCarDriverColumns, buildCCarDriverJoins),
		CCarEntries: buildJoinSet[cCarEntryJoins[Q]](CCarEntryColumns, buildCCarEntryJoins),
		CCarTeams:   buildJoinSet[cCarTeamJoins[Q]](CCarTeamColumns, buildCCarTeamJoins),
		Events:      buildJoinSet[eventJoins[Q]](EventColumns, buildEventJoins),
		Tenants:     buildJoinSet[tenantJoins[Q]](TenantColumns, buildTenantJoins),
		Tracks:      buildJoinSet[trackJoins[Q]](TrackColumns, buildTrackJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}

// ErrUniqueConstraint captures all unique constraint errors by explicitly leaving `s` empty.
var ErrUniqueConstraint = &UniqueConstraintError{s: ""}

type UniqueConstraintError struct {
	// schema is the schema where the unique constraint is defined.
	schema string
	// table is the name of the table where the unique constraint is defined.
	table string
	// columns are the columns constituting the unique constraint.
	columns []string
	// s is a string uniquely identifying the constraint in the raw error message returned from the database.
	s string
}

func (e *UniqueConstraintError) Error() string {
	return e.s
}

func (e *UniqueConstraintError) Is(target error) bool {
	err, ok := target.(*pq.Error)
	if !ok {
		return false
	}
	return err.Code == "23505" && (e.s == "" || err.Constraint == e.s)
}
