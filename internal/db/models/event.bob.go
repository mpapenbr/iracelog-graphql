// Code generated by BobGen psql v0.34.2. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	mytypes "github.com/mpapenbr/iracelog-graphql/internal/db/mytypes"
	"github.com/shopspring/decimal"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
)

// Event is an object representing the database table.
type Event struct {
	ID                int32            `db:"id,pk" `
	EventKey          string           `db:"event_key" `
	Name              string           `db:"name" `
	Description       null.Val[string] `db:"description" `
	EventTime         time.Time        `db:"event_time" `
	RaceloggerVersion string           `db:"racelogger_version" `
	TeamRacing        bool             `db:"team_racing" `
	MultiClass        bool             `db:"multi_class" `
	NumCarTypes       int32            `db:"num_car_types" `
	NumCarClasses     int32            `db:"num_car_classes" `
	IrSessionID       null.Val[int32]  `db:"ir_session_id" `
	TrackID           int32            `db:"track_id" `
	PitSpeed          decimal.Decimal  `db:"pit_speed" `
	// timestamp of the race start
	ReplayMinTimestamp time.Time `db:"replay_min_timestamp" `
	// session time of the race start
	ReplayMinSessionTime decimal.Decimal `db:"replay_min_session_time" `
	// session time of the race end
	ReplayMaxSessionTime decimal.Decimal           `db:"replay_max_session_time" `
	Sessions             mytypes.EventSessionSlice `db:"sessions" `
	IrSubSessionID       int32                     `db:"ir_sub_session_id" `
	TenantID             int32                     `db:"tenant_id" `

	R eventR `db:"-" `
}

// EventSlice is an alias for a slice of pointers to Event.
// This should almost always be used instead of []*Event.
type EventSlice []*Event

// Events contains methods to work with the event table
var Events = psql.NewTablex[*Event, EventSlice, *EventSetter]("", "event")

// EventsQuery is a query on the event table
type EventsQuery = *psql.ViewQuery[*Event, EventSlice]

// eventR is where relationships are stored.
type eventR struct {
	CCars       CCarSlice      // c_car.c_car_event_id_fkey
	CCarEntries CCarEntrySlice // c_car_entry.c_car_entry_event_id_fkey
	Tenant      *Tenant        // event.event_tenant_id_fk
	Track       *Track         // event.event_track_id_fkey
}

type eventColumnNames struct {
	ID                   string
	EventKey             string
	Name                 string
	Description          string
	EventTime            string
	RaceloggerVersion    string
	TeamRacing           string
	MultiClass           string
	NumCarTypes          string
	NumCarClasses        string
	IrSessionID          string
	TrackID              string
	PitSpeed             string
	ReplayMinTimestamp   string
	ReplayMinSessionTime string
	ReplayMaxSessionTime string
	Sessions             string
	IrSubSessionID       string
	TenantID             string
}

var EventColumns = buildEventColumns("event")

type eventColumns struct {
	tableAlias           string
	ID                   psql.Expression
	EventKey             psql.Expression
	Name                 psql.Expression
	Description          psql.Expression
	EventTime            psql.Expression
	RaceloggerVersion    psql.Expression
	TeamRacing           psql.Expression
	MultiClass           psql.Expression
	NumCarTypes          psql.Expression
	NumCarClasses        psql.Expression
	IrSessionID          psql.Expression
	TrackID              psql.Expression
	PitSpeed             psql.Expression
	ReplayMinTimestamp   psql.Expression
	ReplayMinSessionTime psql.Expression
	ReplayMaxSessionTime psql.Expression
	Sessions             psql.Expression
	IrSubSessionID       psql.Expression
	TenantID             psql.Expression
}

func (c eventColumns) Alias() string {
	return c.tableAlias
}

func (eventColumns) AliasedAs(alias string) eventColumns {
	return buildEventColumns(alias)
}

func buildEventColumns(alias string) eventColumns {
	return eventColumns{
		tableAlias:           alias,
		ID:                   psql.Quote(alias, "id"),
		EventKey:             psql.Quote(alias, "event_key"),
		Name:                 psql.Quote(alias, "name"),
		Description:          psql.Quote(alias, "description"),
		EventTime:            psql.Quote(alias, "event_time"),
		RaceloggerVersion:    psql.Quote(alias, "racelogger_version"),
		TeamRacing:           psql.Quote(alias, "team_racing"),
		MultiClass:           psql.Quote(alias, "multi_class"),
		NumCarTypes:          psql.Quote(alias, "num_car_types"),
		NumCarClasses:        psql.Quote(alias, "num_car_classes"),
		IrSessionID:          psql.Quote(alias, "ir_session_id"),
		TrackID:              psql.Quote(alias, "track_id"),
		PitSpeed:             psql.Quote(alias, "pit_speed"),
		ReplayMinTimestamp:   psql.Quote(alias, "replay_min_timestamp"),
		ReplayMinSessionTime: psql.Quote(alias, "replay_min_session_time"),
		ReplayMaxSessionTime: psql.Quote(alias, "replay_max_session_time"),
		Sessions:             psql.Quote(alias, "sessions"),
		IrSubSessionID:       psql.Quote(alias, "ir_sub_session_id"),
		TenantID:             psql.Quote(alias, "tenant_id"),
	}
}

type eventWhere[Q psql.Filterable] struct {
	ID                   psql.WhereMod[Q, int32]
	EventKey             psql.WhereMod[Q, string]
	Name                 psql.WhereMod[Q, string]
	Description          psql.WhereNullMod[Q, string]
	EventTime            psql.WhereMod[Q, time.Time]
	RaceloggerVersion    psql.WhereMod[Q, string]
	TeamRacing           psql.WhereMod[Q, bool]
	MultiClass           psql.WhereMod[Q, bool]
	NumCarTypes          psql.WhereMod[Q, int32]
	NumCarClasses        psql.WhereMod[Q, int32]
	IrSessionID          psql.WhereNullMod[Q, int32]
	TrackID              psql.WhereMod[Q, int32]
	PitSpeed             psql.WhereMod[Q, decimal.Decimal]
	ReplayMinTimestamp   psql.WhereMod[Q, time.Time]
	ReplayMinSessionTime psql.WhereMod[Q, decimal.Decimal]
	ReplayMaxSessionTime psql.WhereMod[Q, decimal.Decimal]
	Sessions             psql.WhereMod[Q, mytypes.EventSessionSlice]
	IrSubSessionID       psql.WhereMod[Q, int32]
	TenantID             psql.WhereMod[Q, int32]
}

func (eventWhere[Q]) AliasedAs(alias string) eventWhere[Q] {
	return buildEventWhere[Q](buildEventColumns(alias))
}

func buildEventWhere[Q psql.Filterable](cols eventColumns) eventWhere[Q] {
	return eventWhere[Q]{
		ID:                   psql.Where[Q, int32](cols.ID),
		EventKey:             psql.Where[Q, string](cols.EventKey),
		Name:                 psql.Where[Q, string](cols.Name),
		Description:          psql.WhereNull[Q, string](cols.Description),
		EventTime:            psql.Where[Q, time.Time](cols.EventTime),
		RaceloggerVersion:    psql.Where[Q, string](cols.RaceloggerVersion),
		TeamRacing:           psql.Where[Q, bool](cols.TeamRacing),
		MultiClass:           psql.Where[Q, bool](cols.MultiClass),
		NumCarTypes:          psql.Where[Q, int32](cols.NumCarTypes),
		NumCarClasses:        psql.Where[Q, int32](cols.NumCarClasses),
		IrSessionID:          psql.WhereNull[Q, int32](cols.IrSessionID),
		TrackID:              psql.Where[Q, int32](cols.TrackID),
		PitSpeed:             psql.Where[Q, decimal.Decimal](cols.PitSpeed),
		ReplayMinTimestamp:   psql.Where[Q, time.Time](cols.ReplayMinTimestamp),
		ReplayMinSessionTime: psql.Where[Q, decimal.Decimal](cols.ReplayMinSessionTime),
		ReplayMaxSessionTime: psql.Where[Q, decimal.Decimal](cols.ReplayMaxSessionTime),
		Sessions:             psql.Where[Q, mytypes.EventSessionSlice](cols.Sessions),
		IrSubSessionID:       psql.Where[Q, int32](cols.IrSubSessionID),
		TenantID:             psql.Where[Q, int32](cols.TenantID),
	}
}

var EventErrors = &eventErrors{
	ErrUniqueEventPkey: &UniqueConstraintError{s: "event_pkey"},

	ErrUniqueEventEventKeyKey: &UniqueConstraintError{s: "event_event_key_key"},
}

type eventErrors struct {
	ErrUniqueEventPkey *UniqueConstraintError

	ErrUniqueEventEventKeyKey *UniqueConstraintError
}

// EventSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type EventSetter struct {
	ID                   omit.Val[int32]                     `db:"id,pk" `
	EventKey             omit.Val[string]                    `db:"event_key" `
	Name                 omit.Val[string]                    `db:"name" `
	Description          omitnull.Val[string]                `db:"description" `
	EventTime            omit.Val[time.Time]                 `db:"event_time" `
	RaceloggerVersion    omit.Val[string]                    `db:"racelogger_version" `
	TeamRacing           omit.Val[bool]                      `db:"team_racing" `
	MultiClass           omit.Val[bool]                      `db:"multi_class" `
	NumCarTypes          omit.Val[int32]                     `db:"num_car_types" `
	NumCarClasses        omit.Val[int32]                     `db:"num_car_classes" `
	IrSessionID          omitnull.Val[int32]                 `db:"ir_session_id" `
	TrackID              omit.Val[int32]                     `db:"track_id" `
	PitSpeed             omit.Val[decimal.Decimal]           `db:"pit_speed" `
	ReplayMinTimestamp   omit.Val[time.Time]                 `db:"replay_min_timestamp" `
	ReplayMinSessionTime omit.Val[decimal.Decimal]           `db:"replay_min_session_time" `
	ReplayMaxSessionTime omit.Val[decimal.Decimal]           `db:"replay_max_session_time" `
	Sessions             omit.Val[mytypes.EventSessionSlice] `db:"sessions" `
	IrSubSessionID       omit.Val[int32]                     `db:"ir_sub_session_id" `
	TenantID             omit.Val[int32]                     `db:"tenant_id" `
}

func (s EventSetter) SetColumns() []string {
	vals := make([]string, 0, 19)
	if !s.ID.IsUnset() {
		vals = append(vals, "id")
	}

	if !s.EventKey.IsUnset() {
		vals = append(vals, "event_key")
	}

	if !s.Name.IsUnset() {
		vals = append(vals, "name")
	}

	if !s.Description.IsUnset() {
		vals = append(vals, "description")
	}

	if !s.EventTime.IsUnset() {
		vals = append(vals, "event_time")
	}

	if !s.RaceloggerVersion.IsUnset() {
		vals = append(vals, "racelogger_version")
	}

	if !s.TeamRacing.IsUnset() {
		vals = append(vals, "team_racing")
	}

	if !s.MultiClass.IsUnset() {
		vals = append(vals, "multi_class")
	}

	if !s.NumCarTypes.IsUnset() {
		vals = append(vals, "num_car_types")
	}

	if !s.NumCarClasses.IsUnset() {
		vals = append(vals, "num_car_classes")
	}

	if !s.IrSessionID.IsUnset() {
		vals = append(vals, "ir_session_id")
	}

	if !s.TrackID.IsUnset() {
		vals = append(vals, "track_id")
	}

	if !s.PitSpeed.IsUnset() {
		vals = append(vals, "pit_speed")
	}

	if !s.ReplayMinTimestamp.IsUnset() {
		vals = append(vals, "replay_min_timestamp")
	}

	if !s.ReplayMinSessionTime.IsUnset() {
		vals = append(vals, "replay_min_session_time")
	}

	if !s.ReplayMaxSessionTime.IsUnset() {
		vals = append(vals, "replay_max_session_time")
	}

	if !s.Sessions.IsUnset() {
		vals = append(vals, "sessions")
	}

	if !s.IrSubSessionID.IsUnset() {
		vals = append(vals, "ir_sub_session_id")
	}

	if !s.TenantID.IsUnset() {
		vals = append(vals, "tenant_id")
	}

	return vals
}

func (s EventSetter) Overwrite(t *Event) {
	if !s.ID.IsUnset() {
		t.ID, _ = s.ID.Get()
	}
	if !s.EventKey.IsUnset() {
		t.EventKey, _ = s.EventKey.Get()
	}
	if !s.Name.IsUnset() {
		t.Name, _ = s.Name.Get()
	}
	if !s.Description.IsUnset() {
		t.Description, _ = s.Description.GetNull()
	}
	if !s.EventTime.IsUnset() {
		t.EventTime, _ = s.EventTime.Get()
	}
	if !s.RaceloggerVersion.IsUnset() {
		t.RaceloggerVersion, _ = s.RaceloggerVersion.Get()
	}
	if !s.TeamRacing.IsUnset() {
		t.TeamRacing, _ = s.TeamRacing.Get()
	}
	if !s.MultiClass.IsUnset() {
		t.MultiClass, _ = s.MultiClass.Get()
	}
	if !s.NumCarTypes.IsUnset() {
		t.NumCarTypes, _ = s.NumCarTypes.Get()
	}
	if !s.NumCarClasses.IsUnset() {
		t.NumCarClasses, _ = s.NumCarClasses.Get()
	}
	if !s.IrSessionID.IsUnset() {
		t.IrSessionID, _ = s.IrSessionID.GetNull()
	}
	if !s.TrackID.IsUnset() {
		t.TrackID, _ = s.TrackID.Get()
	}
	if !s.PitSpeed.IsUnset() {
		t.PitSpeed, _ = s.PitSpeed.Get()
	}
	if !s.ReplayMinTimestamp.IsUnset() {
		t.ReplayMinTimestamp, _ = s.ReplayMinTimestamp.Get()
	}
	if !s.ReplayMinSessionTime.IsUnset() {
		t.ReplayMinSessionTime, _ = s.ReplayMinSessionTime.Get()
	}
	if !s.ReplayMaxSessionTime.IsUnset() {
		t.ReplayMaxSessionTime, _ = s.ReplayMaxSessionTime.Get()
	}
	if !s.Sessions.IsUnset() {
		t.Sessions, _ = s.Sessions.Get()
	}
	if !s.IrSubSessionID.IsUnset() {
		t.IrSubSessionID, _ = s.IrSubSessionID.Get()
	}
	if !s.TenantID.IsUnset() {
		t.TenantID, _ = s.TenantID.Get()
	}
}

func (s *EventSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Events.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 19)
		if s.ID.IsUnset() {
			vals[0] = psql.Raw("DEFAULT")
		} else {
			vals[0] = psql.Arg(s.ID)
		}

		if s.EventKey.IsUnset() {
			vals[1] = psql.Raw("DEFAULT")
		} else {
			vals[1] = psql.Arg(s.EventKey)
		}

		if s.Name.IsUnset() {
			vals[2] = psql.Raw("DEFAULT")
		} else {
			vals[2] = psql.Arg(s.Name)
		}

		if s.Description.IsUnset() {
			vals[3] = psql.Raw("DEFAULT")
		} else {
			vals[3] = psql.Arg(s.Description)
		}

		if s.EventTime.IsUnset() {
			vals[4] = psql.Raw("DEFAULT")
		} else {
			vals[4] = psql.Arg(s.EventTime)
		}

		if s.RaceloggerVersion.IsUnset() {
			vals[5] = psql.Raw("DEFAULT")
		} else {
			vals[5] = psql.Arg(s.RaceloggerVersion)
		}

		if s.TeamRacing.IsUnset() {
			vals[6] = psql.Raw("DEFAULT")
		} else {
			vals[6] = psql.Arg(s.TeamRacing)
		}

		if s.MultiClass.IsUnset() {
			vals[7] = psql.Raw("DEFAULT")
		} else {
			vals[7] = psql.Arg(s.MultiClass)
		}

		if s.NumCarTypes.IsUnset() {
			vals[8] = psql.Raw("DEFAULT")
		} else {
			vals[8] = psql.Arg(s.NumCarTypes)
		}

		if s.NumCarClasses.IsUnset() {
			vals[9] = psql.Raw("DEFAULT")
		} else {
			vals[9] = psql.Arg(s.NumCarClasses)
		}

		if s.IrSessionID.IsUnset() {
			vals[10] = psql.Raw("DEFAULT")
		} else {
			vals[10] = psql.Arg(s.IrSessionID)
		}

		if s.TrackID.IsUnset() {
			vals[11] = psql.Raw("DEFAULT")
		} else {
			vals[11] = psql.Arg(s.TrackID)
		}

		if s.PitSpeed.IsUnset() {
			vals[12] = psql.Raw("DEFAULT")
		} else {
			vals[12] = psql.Arg(s.PitSpeed)
		}

		if s.ReplayMinTimestamp.IsUnset() {
			vals[13] = psql.Raw("DEFAULT")
		} else {
			vals[13] = psql.Arg(s.ReplayMinTimestamp)
		}

		if s.ReplayMinSessionTime.IsUnset() {
			vals[14] = psql.Raw("DEFAULT")
		} else {
			vals[14] = psql.Arg(s.ReplayMinSessionTime)
		}

		if s.ReplayMaxSessionTime.IsUnset() {
			vals[15] = psql.Raw("DEFAULT")
		} else {
			vals[15] = psql.Arg(s.ReplayMaxSessionTime)
		}

		if s.Sessions.IsUnset() {
			vals[16] = psql.Raw("DEFAULT")
		} else {
			vals[16] = psql.Arg(s.Sessions)
		}

		if s.IrSubSessionID.IsUnset() {
			vals[17] = psql.Raw("DEFAULT")
		} else {
			vals[17] = psql.Arg(s.IrSubSessionID)
		}

		if s.TenantID.IsUnset() {
			vals[18] = psql.Raw("DEFAULT")
		} else {
			vals[18] = psql.Arg(s.TenantID)
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s EventSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s EventSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 19)

	if !s.ID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if !s.EventKey.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "event_key")...),
			psql.Arg(s.EventKey),
		}})
	}

	if !s.Name.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "name")...),
			psql.Arg(s.Name),
		}})
	}

	if !s.Description.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "description")...),
			psql.Arg(s.Description),
		}})
	}

	if !s.EventTime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "event_time")...),
			psql.Arg(s.EventTime),
		}})
	}

	if !s.RaceloggerVersion.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "racelogger_version")...),
			psql.Arg(s.RaceloggerVersion),
		}})
	}

	if !s.TeamRacing.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "team_racing")...),
			psql.Arg(s.TeamRacing),
		}})
	}

	if !s.MultiClass.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "multi_class")...),
			psql.Arg(s.MultiClass),
		}})
	}

	if !s.NumCarTypes.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "num_car_types")...),
			psql.Arg(s.NumCarTypes),
		}})
	}

	if !s.NumCarClasses.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "num_car_classes")...),
			psql.Arg(s.NumCarClasses),
		}})
	}

	if !s.IrSessionID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "ir_session_id")...),
			psql.Arg(s.IrSessionID),
		}})
	}

	if !s.TrackID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "track_id")...),
			psql.Arg(s.TrackID),
		}})
	}

	if !s.PitSpeed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "pit_speed")...),
			psql.Arg(s.PitSpeed),
		}})
	}

	if !s.ReplayMinTimestamp.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "replay_min_timestamp")...),
			psql.Arg(s.ReplayMinTimestamp),
		}})
	}

	if !s.ReplayMinSessionTime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "replay_min_session_time")...),
			psql.Arg(s.ReplayMinSessionTime),
		}})
	}

	if !s.ReplayMaxSessionTime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "replay_max_session_time")...),
			psql.Arg(s.ReplayMaxSessionTime),
		}})
	}

	if !s.Sessions.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sessions")...),
			psql.Arg(s.Sessions),
		}})
	}

	if !s.IrSubSessionID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "ir_sub_session_id")...),
			psql.Arg(s.IrSubSessionID),
		}})
	}

	if !s.TenantID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "tenant_id")...),
			psql.Arg(s.TenantID),
		}})
	}

	return exprs
}

// FindEvent retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindEvent(ctx context.Context, exec bob.Executor, IDPK int32, cols ...string) (*Event, error) {
	if len(cols) == 0 {
		return Events.Query(
			SelectWhere.Events.ID.EQ(IDPK),
		).One(ctx, exec)
	}

	return Events.Query(
		SelectWhere.Events.ID.EQ(IDPK),
		sm.Columns(Events.Columns().Only(cols...)),
	).One(ctx, exec)
}

// EventExists checks the presence of a single record by primary key
func EventExists(ctx context.Context, exec bob.Executor, IDPK int32) (bool, error) {
	return Events.Query(
		SelectWhere.Events.ID.EQ(IDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Event is retrieved from the database
func (o *Event) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Events.AfterSelectHooks.RunHooks(ctx, exec, EventSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Events.AfterInsertHooks.RunHooks(ctx, exec, EventSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Events.AfterUpdateHooks.RunHooks(ctx, exec, EventSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Events.AfterDeleteHooks.RunHooks(ctx, exec, EventSlice{o})
	}

	return err
}

// PrimaryKeyVals returns the primary key values of the Event
func (o *Event) PrimaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

func (o *Event) pkEQ() dialect.Expression {
	return psql.Quote("event", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.PrimaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Event
func (o *Event) Update(ctx context.Context, exec bob.Executor, s *EventSetter) error {
	v, err := Events.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single Event record with an executor
func (o *Event) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Events.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Event using the executor
func (o *Event) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Events.Query(
		SelectWhere.Events.ID.EQ(o.ID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after EventSlice is retrieved from the database
func (o EventSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Events.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Events.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Events.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Events.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o EventSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("event", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.PrimaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o EventSlice) copyMatchingRows(from ...*Event) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o EventSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Events.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Event:
				o.copyMatchingRows(retrieved)
			case []*Event:
				o.copyMatchingRows(retrieved...)
			case EventSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Event or a slice of Event
				// then run the AfterUpdateHooks on the slice
				_, err = Events.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o EventSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Events.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Event:
				o.copyMatchingRows(retrieved)
			case []*Event:
				o.copyMatchingRows(retrieved...)
			case EventSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Event or a slice of Event
				// then run the AfterDeleteHooks on the slice
				_, err = Events.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o EventSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals EventSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Events.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o EventSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Events.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o EventSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Events.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type eventJoins[Q dialect.Joinable] struct {
	typ         string
	CCars       func(context.Context) modAs[Q, cCarColumns]
	CCarEntries func(context.Context) modAs[Q, cCarEntryColumns]
	Tenant      func(context.Context) modAs[Q, tenantColumns]
	Track       func(context.Context) modAs[Q, trackColumns]
}

func (j eventJoins[Q]) aliasedAs(alias string) eventJoins[Q] {
	return buildEventJoins[Q](buildEventColumns(alias), j.typ)
}

func buildEventJoins[Q dialect.Joinable](cols eventColumns, typ string) eventJoins[Q] {
	return eventJoins[Q]{
		typ:         typ,
		CCars:       eventsJoinCCars[Q](cols, typ),
		CCarEntries: eventsJoinCCarEntries[Q](cols, typ),
		Tenant:      eventsJoinTenant[Q](cols, typ),
		Track:       eventsJoinTrack[Q](cols, typ),
	}
}

func eventsJoinCCars[Q dialect.Joinable](from eventColumns, typ string) func(context.Context) modAs[Q, cCarColumns] {
	return func(ctx context.Context) modAs[Q, cCarColumns] {
		return modAs[Q, cCarColumns]{
			c: CCarColumns,
			f: func(to cCarColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CCars.Name().As(to.Alias())).On(
						to.EventID.EQ(from.ID),
					))
				}

				return mods
			},
		}
	}
}

func eventsJoinCCarEntries[Q dialect.Joinable](from eventColumns, typ string) func(context.Context) modAs[Q, cCarEntryColumns] {
	return func(ctx context.Context) modAs[Q, cCarEntryColumns] {
		return modAs[Q, cCarEntryColumns]{
			c: CCarEntryColumns,
			f: func(to cCarEntryColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CCarEntries.Name().As(to.Alias())).On(
						to.EventID.EQ(from.ID),
					))
				}

				return mods
			},
		}
	}
}

func eventsJoinTenant[Q dialect.Joinable](from eventColumns, typ string) func(context.Context) modAs[Q, tenantColumns] {
	return func(ctx context.Context) modAs[Q, tenantColumns] {
		return modAs[Q, tenantColumns]{
			c: TenantColumns,
			f: func(to tenantColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Tenants.Name().As(to.Alias())).On(
						to.ID.EQ(from.TenantID),
					))
				}

				return mods
			},
		}
	}
}

func eventsJoinTrack[Q dialect.Joinable](from eventColumns, typ string) func(context.Context) modAs[Q, trackColumns] {
	return func(ctx context.Context) modAs[Q, trackColumns] {
		return modAs[Q, trackColumns]{
			c: TrackColumns,
			f: func(to trackColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Tracks.Name().As(to.Alias())).On(
						to.ID.EQ(from.TrackID),
					))
				}

				return mods
			},
		}
	}
}

// CCars starts a query for related objects on c_car
func (o *Event) CCars(mods ...bob.Mod[*dialect.SelectQuery]) CCarsQuery {
	return CCars.Query(append(mods,
		sm.Where(CCarColumns.EventID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os EventSlice) CCars(mods ...bob.Mod[*dialect.SelectQuery]) CCarsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.ID)
	}

	return CCars.Query(append(mods,
		sm.Where(psql.Group(CCarColumns.EventID).In(PKArgs...)),
	)...)
}

// CCarEntries starts a query for related objects on c_car_entry
func (o *Event) CCarEntries(mods ...bob.Mod[*dialect.SelectQuery]) CCarEntriesQuery {
	return CCarEntries.Query(append(mods,
		sm.Where(CCarEntryColumns.EventID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os EventSlice) CCarEntries(mods ...bob.Mod[*dialect.SelectQuery]) CCarEntriesQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.ID)
	}

	return CCarEntries.Query(append(mods,
		sm.Where(psql.Group(CCarEntryColumns.EventID).In(PKArgs...)),
	)...)
}

// Tenant starts a query for related objects on tenant
func (o *Event) Tenant(mods ...bob.Mod[*dialect.SelectQuery]) TenantsQuery {
	return Tenants.Query(append(mods,
		sm.Where(TenantColumns.ID.EQ(psql.Arg(o.TenantID))),
	)...)
}

func (os EventSlice) Tenant(mods ...bob.Mod[*dialect.SelectQuery]) TenantsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.TenantID)
	}

	return Tenants.Query(append(mods,
		sm.Where(psql.Group(TenantColumns.ID).In(PKArgs...)),
	)...)
}

// Track starts a query for related objects on track
func (o *Event) Track(mods ...bob.Mod[*dialect.SelectQuery]) TracksQuery {
	return Tracks.Query(append(mods,
		sm.Where(TrackColumns.ID.EQ(psql.Arg(o.TrackID))),
	)...)
}

func (os EventSlice) Track(mods ...bob.Mod[*dialect.SelectQuery]) TracksQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.TrackID)
	}

	return Tracks.Query(append(mods,
		sm.Where(psql.Group(TrackColumns.ID).In(PKArgs...)),
	)...)
}

func (o *Event) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "CCars":
		rels, ok := retrieved.(CCarSlice)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.CCars = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Event = o
			}
		}
		return nil
	case "CCarEntries":
		rels, ok := retrieved.(CCarEntrySlice)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.CCarEntries = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Event = o
			}
		}
		return nil
	case "Tenant":
		rel, ok := retrieved.(*Tenant)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.Tenant = rel

		if rel != nil {
			rel.R.Events = EventSlice{o}
		}
		return nil
	case "Track":
		rel, ok := retrieved.(*Track)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.Track = rel

		if rel != nil {
			rel.R.Events = EventSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("event has no relationship %q", name)
	}
}

func ThenLoadEventCCars(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadEventCCars(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load EventCCars", retrieved)
		}

		err := loader.LoadEventCCars(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadEventCCars loads the event's CCars into the .R struct
func (o *Event) LoadEventCCars(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CCars = nil

	related, err := o.CCars(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Event = o
	}

	o.R.CCars = related
	return nil
}

// LoadEventCCars loads the event's CCars into the .R struct
func (os EventSlice) LoadEventCCars(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	cCars, err := os.CCars(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.CCars = nil
	}

	for _, o := range os {
		for _, rel := range cCars {
			if o.ID != rel.EventID {
				continue
			}

			rel.R.Event = o

			o.R.CCars = append(o.R.CCars, rel)
		}
	}

	return nil
}

func ThenLoadEventCCarEntries(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadEventCCarEntries(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load EventCCarEntries", retrieved)
		}

		err := loader.LoadEventCCarEntries(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadEventCCarEntries loads the event's CCarEntries into the .R struct
func (o *Event) LoadEventCCarEntries(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CCarEntries = nil

	related, err := o.CCarEntries(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Event = o
	}

	o.R.CCarEntries = related
	return nil
}

// LoadEventCCarEntries loads the event's CCarEntries into the .R struct
func (os EventSlice) LoadEventCCarEntries(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	cCarEntries, err := os.CCarEntries(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.CCarEntries = nil
	}

	for _, o := range os {
		for _, rel := range cCarEntries {
			if o.ID != rel.EventID {
				continue
			}

			rel.R.Event = o

			o.R.CCarEntries = append(o.R.CCarEntries, rel)
		}
	}

	return nil
}

func PreloadEventTenant(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Tenant, TenantSlice](orm.Relationship{
		Name: "Tenant",
		Sides: []orm.RelSide{
			{
				From: TableNames.Events,
				To:   TableNames.Tenants,
				FromColumns: []string{
					ColumnNames.Events.TenantID,
				},
				ToColumns: []string{
					ColumnNames.Tenants.ID,
				},
			},
		},
	}, Tenants.Columns().Names(), opts...)
}

func ThenLoadEventTenant(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadEventTenant(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load EventTenant", retrieved)
		}

		err := loader.LoadEventTenant(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadEventTenant loads the event's Tenant into the .R struct
func (o *Event) LoadEventTenant(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Tenant = nil

	related, err := o.Tenant(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Events = EventSlice{o}

	o.R.Tenant = related
	return nil
}

// LoadEventTenant loads the event's Tenant into the .R struct
func (os EventSlice) LoadEventTenant(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	tenants, err := os.Tenant(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range tenants {
			if o.TenantID != rel.ID {
				continue
			}

			rel.R.Events = append(rel.R.Events, o)

			o.R.Tenant = rel
			break
		}
	}

	return nil
}

func PreloadEventTrack(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Track, TrackSlice](orm.Relationship{
		Name: "Track",
		Sides: []orm.RelSide{
			{
				From: TableNames.Events,
				To:   TableNames.Tracks,
				FromColumns: []string{
					ColumnNames.Events.TrackID,
				},
				ToColumns: []string{
					ColumnNames.Tracks.ID,
				},
			},
		},
	}, Tracks.Columns().Names(), opts...)
}

func ThenLoadEventTrack(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadEventTrack(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load EventTrack", retrieved)
		}

		err := loader.LoadEventTrack(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadEventTrack loads the event's Track into the .R struct
func (o *Event) LoadEventTrack(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Track = nil

	related, err := o.Track(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Events = EventSlice{o}

	o.R.Track = related
	return nil
}

// LoadEventTrack loads the event's Track into the .R struct
func (os EventSlice) LoadEventTrack(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	tracks, err := os.Track(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range tracks {
			if o.TrackID != rel.ID {
				continue
			}

			rel.R.Events = append(rel.R.Events, o)

			o.R.Track = rel
			break
		}
	}

	return nil
}

func insertEventCCars0(ctx context.Context, exec bob.Executor, cCars1 []*CCarSetter, event0 *Event) (CCarSlice, error) {
	for i := range cCars1 {
		cCars1[i].EventID = omit.From(event0.ID)
	}

	ret, err := CCars.Insert(bob.ToMods(cCars1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertEventCCars0: %w", err)
	}

	return ret, nil
}

func attachEventCCars0(ctx context.Context, exec bob.Executor, count int, cCars1 CCarSlice, event0 *Event) (CCarSlice, error) {
	setter := &CCarSetter{
		EventID: omit.From(event0.ID),
	}

	err := cCars1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventCCars0: %w", err)
	}

	return cCars1, nil
}

func (event0 *Event) InsertCCars(ctx context.Context, exec bob.Executor, related ...*CCarSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	cCars1, err := insertEventCCars0(ctx, exec, related, event0)
	if err != nil {
		return err
	}

	event0.R.CCars = append(event0.R.CCars, cCars1...)

	for _, rel := range cCars1 {
		rel.R.Event = event0
	}
	return nil
}

func (event0 *Event) AttachCCars(ctx context.Context, exec bob.Executor, related ...*CCar) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	cCars1 := CCarSlice(related)

	_, err = attachEventCCars0(ctx, exec, len(related), cCars1, event0)
	if err != nil {
		return err
	}

	event0.R.CCars = append(event0.R.CCars, cCars1...)

	for _, rel := range related {
		rel.R.Event = event0
	}

	return nil
}

func insertEventCCarEntries0(ctx context.Context, exec bob.Executor, cCarEntries1 []*CCarEntrySetter, event0 *Event) (CCarEntrySlice, error) {
	for i := range cCarEntries1 {
		cCarEntries1[i].EventID = omit.From(event0.ID)
	}

	ret, err := CCarEntries.Insert(bob.ToMods(cCarEntries1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertEventCCarEntries0: %w", err)
	}

	return ret, nil
}

func attachEventCCarEntries0(ctx context.Context, exec bob.Executor, count int, cCarEntries1 CCarEntrySlice, event0 *Event) (CCarEntrySlice, error) {
	setter := &CCarEntrySetter{
		EventID: omit.From(event0.ID),
	}

	err := cCarEntries1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventCCarEntries0: %w", err)
	}

	return cCarEntries1, nil
}

func (event0 *Event) InsertCCarEntries(ctx context.Context, exec bob.Executor, related ...*CCarEntrySetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	cCarEntries1, err := insertEventCCarEntries0(ctx, exec, related, event0)
	if err != nil {
		return err
	}

	event0.R.CCarEntries = append(event0.R.CCarEntries, cCarEntries1...)

	for _, rel := range cCarEntries1 {
		rel.R.Event = event0
	}
	return nil
}

func (event0 *Event) AttachCCarEntries(ctx context.Context, exec bob.Executor, related ...*CCarEntry) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	cCarEntries1 := CCarEntrySlice(related)

	_, err = attachEventCCarEntries0(ctx, exec, len(related), cCarEntries1, event0)
	if err != nil {
		return err
	}

	event0.R.CCarEntries = append(event0.R.CCarEntries, cCarEntries1...)

	for _, rel := range related {
		rel.R.Event = event0
	}

	return nil
}

func attachEventTenant0(ctx context.Context, exec bob.Executor, count int, event0 *Event, tenant1 *Tenant) (*Event, error) {
	setter := &EventSetter{
		TenantID: omit.From(tenant1.ID),
	}

	err := event0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventTenant0: %w", err)
	}

	return event0, nil
}

func (event0 *Event) InsertTenant(ctx context.Context, exec bob.Executor, related *TenantSetter) error {
	tenant1, err := Tenants.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachEventTenant0(ctx, exec, 1, event0, tenant1)
	if err != nil {
		return err
	}

	event0.R.Tenant = tenant1

	tenant1.R.Events = append(tenant1.R.Events, event0)

	return nil
}

func (event0 *Event) AttachTenant(ctx context.Context, exec bob.Executor, tenant1 *Tenant) error {
	var err error

	_, err = attachEventTenant0(ctx, exec, 1, event0, tenant1)
	if err != nil {
		return err
	}

	event0.R.Tenant = tenant1

	tenant1.R.Events = append(tenant1.R.Events, event0)

	return nil
}

func attachEventTrack0(ctx context.Context, exec bob.Executor, count int, event0 *Event, track1 *Track) (*Event, error) {
	setter := &EventSetter{
		TrackID: omit.From(track1.ID),
	}

	err := event0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventTrack0: %w", err)
	}

	return event0, nil
}

func (event0 *Event) InsertTrack(ctx context.Context, exec bob.Executor, related *TrackSetter) error {
	track1, err := Tracks.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachEventTrack0(ctx, exec, 1, event0, track1)
	if err != nil {
		return err
	}

	event0.R.Track = track1

	track1.R.Events = append(track1.R.Events, event0)

	return nil
}

func (event0 *Event) AttachTrack(ctx context.Context, exec bob.Executor, track1 *Track) error {
	var err error

	_, err = attachEventTrack0(ctx, exec, 1, event0, track1)
	if err != nil {
		return err
	}

	event0.R.Track = track1

	track1.R.Events = append(track1.R.Events, event0)

	return nil
}
